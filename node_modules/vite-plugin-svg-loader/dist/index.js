"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const parse_xml_1 = __importDefault(require("@rgrove/parse-xml"));
const svgo_1 = __importDefault(require("svgo"));
const baseConfig_1 = require("./baseConfig");
function default_1(options) {
    const { defaultImport, svgoConfig } = options || {};
    const svgRegex = /\.svg(\?(raw|component))?$/;
    return {
        name: 'vite-plugin-svg',
        enforce: 'pre',
        async load(id) {
            var _a;
            const [path, query] = id.split('?', 2);
            if (!id.match(svgRegex)) {
                return;
            }
            const importType = query || defaultImport;
            if (importType === 'url') {
                return; // Use default svg loader
            }
            let SVGString;
            try {
                SVGString = (0, fs_1.readFileSync)(path, 'utf-8');
            }
            catch (ex) {
                console.warn("File couldn't be loaded, fallback to default loader", ex);
                return; // File couldn't be loaded, fallback to default loader
            }
            if (importType === 'raw') {
                return `export default ${JSON.stringify(SVGString)}`;
            }
            const result = svgo_1.default.optimize(SVGString, {
                ...baseConfig_1.base,
                ...svgoConfig,
                plugins: [...(baseConfig_1.base.plugins || []), ...((svgoConfig === null || svgoConfig === void 0 ? void 0 : svgoConfig.plugins) || [])],
            });
            if ('data' in result) {
                const svgXMLData = (0, parse_xml_1.default)(result.data);
                const svgData = ((_a = svgXMLData.children) === null || _a === void 0 ? void 0 : _a[0]) || {};
                const svgName = path.replace(/(.*\/)*([^.]+).*/gi, '$2');
                const abstractNode = element2AbstractNode({
                    name: svgName,
                    theme: 'custom',
                    extraNodeTransformFactories: [],
                    // @ts-ignore
                })(svgData);
                if (importType === 'data') {
                    return `export default ${JSON.stringify(abstractNode)}`;
                }
                return `export default ${JSON.stringify({ icon: abstractNode, name: svgName, theme: 'custom' })}`;
            }
            else {
                console.warn('svgo optimize error');
                return;
            }
        },
    };
}
exports.default = default_1;
function element2AbstractNode({ name, theme, extraNodeTransformFactories }) {
    return ({ name: tag, attributes, children }) => {
        const data = {
            tag,
            attrs: { ...attributes },
            children: children
                .filter(({ type }) => type === 'element')
                .map(item => element2AbstractNode({
                name,
                theme,
                extraNodeTransformFactories,
            })(item)),
        };
        if (!(Array.isArray(data.children) && data.children.length > 0)) {
            // @ts-ignore
            delete data.children;
        }
        return extraNodeTransformFactories
            .map((factory) => factory({ name, theme }))
            .reduce((transformedNode, extraTransformFn) => extraTransformFn(transformedNode), data);
    };
}
//# sourceMappingURL=index.js.map